# -*- coding: utf-8 -*-
"""Bi_LSTM_s.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T_NsoClSfqsrXQNV09LToAMUxjRweM2p
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import tensorflow as tf
from tensorflow import keras
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import rc
import sklearn
# %matplotlib inline
RANDOM_SEED = 42
np.random.seed(RANDOM_SEED)
tf.random.set_seed(RANDOM_SEED)
import matplotlib.pyplot as plt
plt.rcParams["figure.figsize"] = (5,4)

df = pd.read_csv('/content/drive/MyDrive/Research/weather_five_minutes.csv')

df.drop(['--Timestamp---',' UV '],axis=1,inplace=True)

train_size = int(len(df) * 0.8)
test_size = len(df) - train_size
train, test = df.iloc[0:train_size], df.iloc[train_size:len(df)]
print(len(train), len(test))

from sklearn.preprocessing import MinMaxScaler
f_columns = ['Temp', 'Chill', 'Humid', 'Dewpt',' Wind ','HiWind','Rain ','Barom',' ET  ']
f_transformer = MinMaxScaler()
f_transformer = f_transformer.fit(train[f_columns].to_numpy())
train.loc[:, f_columns] = f_transformer.transform(
  train[f_columns].to_numpy()
)
test.loc[:, f_columns] = f_transformer.transform(
  test[f_columns].to_numpy()
)

solar_transformer = MinMaxScaler()
solar = solar_transformer.fit(train[['Solar']])
train['Solar'] = solar.transform(train[['Solar']])
test['Solar'] = solar.transform(test[['Solar']])

def create_dataset(X, y, time_steps=1):
    Xs, ys = [], []
    for i in range(len(X) - time_steps):
        v = X.iloc[i:(i + time_steps)].values
        Xs.append(v)
        ys.append(y.iloc[i + time_steps])
    return np.array(Xs), np.array(ys)

time_steps = 1
# reshape to [samples, time_steps, n_features]
X_train, y_train = create_dataset(train, train.Solar, time_steps)
X_test, y_test = create_dataset(test, test.Solar, time_steps)
print(X_train.shape, y_train.shape)

from keras.layers import Bidirectional
from keras.layers import LSTM

model = keras.models.Sequential()
model.add(Bidirectional(LSTM(128, input_shape=(X_train.shape[1], X_train.shape[2]),return_sequences=True)))
model.add(tf.keras.layers.LeakyReLU(alpha=0.5))
model.add(Bidirectional(LSTM(64, return_sequences=True)))
model.add(tf.keras.layers.LeakyReLU(alpha=0.5))
model.add(tf.keras.layers.Dropout(0.5))
model.add(Bidirectional(LSTM(32, return_sequences=True)))
model.add(tf.keras.layers.LeakyReLU(alpha=0.5))
model.add(tf.keras.layers.Dropout(0.5))
model.add(Bidirectional(LSTM(16, return_sequences=False)))
model.add(tf.keras.layers.LeakyReLU(alpha=0.5))
model.add(tf.keras.layers.Dropout(0.5))
model.add(tf.keras.layers.Dense(1))

optimizer = keras.optimizers.Adam()
model.compile(loss='mean_squared_error', optimizer=optimizer)

history = model.fit(
    X_train, y_train,
    epochs=30,
    batch_size=256,
    validation_split=0.1,
    shuffle=False
)

y_pred=model.predict(X_test)

plt.rcParams["figure.figsize"] = (6,4)
plt.plot(history.history['loss'],marker='o',label='train')
plt.plot(history.history['val_loss'],marker='o',label='validation')
plt.title('Bi_LSTM ',fontsize=20)
plt.ylabel('loss ',fontsize=15)
plt.xlabel('epochs',fontsize=15)
plt.legend(fontsize=15)

def percentage_error(actual, predicted):
    res = np.empty(actual.shape)
    for j in range(actual.shape[0]):
        if actual[j] != 0:
            res[j] = (actual[j] - predicted[j]) / actual[j]
        else:
            res[j] = predicted[j] / np.mean(actual)
    return res

def mean_absolute_percentage_error(y_test, y_pred): 
    return np.mean(np.abs(percentage_error(np.asarray(y_test), np.asarray(y_pred)))) * 100

mean_absolute_percentage_error(y_test, y_pred)

from sklearn.metrics import mean_squared_error
print(mean_squared_error(y_test,y_pred))
print(np.sqrt(mean_squared_error(y_test,y_pred)))
from sklearn.metrics import mean_absolute_error
print(mean_absolute_error(y_test,y_pred))

plt.rcParams["figure.figsize"] = (8,3)
plt.plot(y_test[0:1000],color='orange',label="Original ")
plt.plot(y_pred[0:1000],color="green",label="Forecast ")

plt.xlabel('Number of Observation',fontsize=20)
plt.ylabel('Solar Energy(W/mÂ²)',fontsize=20)
plt.title('Solar energy prediction using Bi_LSTM',fontsize=25)
plt.legend(fontsize=15)
plt.show()